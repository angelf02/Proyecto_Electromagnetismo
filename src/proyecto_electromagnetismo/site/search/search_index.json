{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Proyecto Electromagnetismo","text":"<p>Bienvenidos al proyecto de simulaci\u00f3n de ecuaciones diferenciales aplicadas a sistemas el\u00e9ctricos.</p>"},{"location":"#participantes","title":"Participantes","text":"<ul> <li>Carlos Echandi Jara (B92687)</li> <li>Natalia Iannarella Arguedas (A83166)</li> <li>\u00c1ngel Fabricio Aguirre Berm\u00fadez (C10152)</li> <li>Mar\u00eda Celeste Ure\u00f1a Sand\u00ed (B98009)</li> </ul>"},{"location":"#descripcion","title":"Descripci\u00f3n","text":"<p>Este proyecto incluye:</p> <ul> <li>M\u00e9todos num\u00e9ricos para resolver ecuaciones diferenciales parciales.</li> <li>Implementaciones en Python y C++.</li> <li>Simulaciones paralelas con OpenMP.</li> <li>Visualizaci\u00f3n de resultados y an\u00e1lisis num\u00e9rico.</li> </ul>"},{"location":"codigo_cpp/Gauss_Seidel/","title":"Soluci\u00f3n de la Ecuaci\u00f3n de Laplace en C++","text":"<p>Este programa en C++ resuelve la ecuaci\u00f3n de Laplace en una grilla 2D utilizando el m\u00e9todo de relajaci\u00f3n iterativa.</p>"},{"location":"codigo_cpp/Gauss_Seidel/#codigo-fuente","title":"C\u00f3digo Fuente","text":"<p>```cpp</p>"},{"location":"codigo_cpp/Gauss_Seidel/#include","title":"include","text":""},{"location":"codigo_cpp/Gauss_Seidel/#include_1","title":"include","text":""},{"location":"codigo_cpp/Gauss_Seidel/#include-para-stdabs","title":"include  // Para std::abs","text":""},{"location":"codigo_cpp/Gauss_Seidel/#include-para-stdmax","title":"include  // Para std::max <p>double calcular_delta(const std::vector &amp;phi, const std::vector &amp;phi_copy) {     double delta = 0.0;     for (size_t i = 0; i &lt; phi.size(); ++i) {         delta = std::max(delta, std::abs(phi[i] - phi_copy[i]));     }     return delta; } <p>int main(int argc, char* argv[]) {     if (argc != 7) {         std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" --N [Tama\u00f1o lineal de la grilla cuadrada (NxN)] --t [Tolerancia] --L [Tama\u00f1o lineal del capacitor cuadrado (LxL)]\" &lt;&lt; std::endl;         return 1;     }</p> <pre><code>std::cout &lt;&lt; \"Bienvenido.\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Se esta calculando la solucion de la ecuacion de Laplace bajo los parametros definidos...\" &lt;&lt; std::endl;\n\nint N = atoi(argv[2]);  // Tama\u00f1o de la grilla (NxN)\ndouble tolerance = atof(argv[4]);  // Tolerancia\nint L = atoi(argv[6]);  // Tama\u00f1o lineal del capacitor fisico\nint grilla_size = N + 1;  // Tama\u00f1o total de la grilla (incluye frontera)\n\nstd::vector&lt;double&gt; phi(grilla_size * grilla_size, 0.0);\n\nint start_y = (N/L) * 2.0;  // Coordenada inicial (y = 2cm)\nint end_y = (N/L) * 8.0;    // Coordenada final (y= 8cm)\nint plate_x1 = (N / L) * 2.0; // L\u00ednea vertical izquierda (x = 2cm)\nint plate_x2 = (N / L) * 8.0; // L\u00ednea vertical derecha (x = 8cm)\n\nfor (int i = start_y; i &lt; end_y; ++i) {\n    phi[i * grilla_size + plate_x1] = 1.0;  // +1V en la placa izquierda\n    phi[i * grilla_size + plate_x2] = -1.0; // -1V en la placa derecha\n}\n\nstd::vector&lt;double&gt; phi_copy = phi;\n\ndouble delta = 1.0;\nint its = 0;\n\nwhile (delta &gt; tolerance) {\n    its++;\n\n    for (int i = 1; i &lt; N; ++i) {\n        for (int j = 1; j &lt; N; ++j) {\n            phi[i * grilla_size + j] = (1.0 / 4.0) *\n                (phi[(i + 1) * grilla_size + j] +\n                 phi[(i - 1) * grilla_size + j] +\n                 phi[i * grilla_size + (j + 1)] +\n                 phi[i * grilla_size + (j - 1)]);\n        }\n    }\n\n    for (int i = start_y; i &lt; end_y; ++i) {\n        phi[i * grilla_size + plate_x1] = 1.0;\n        phi[i * grilla_size + plate_x2] = -1.0;\n    }\n\n    delta = calcular_delta(phi, phi_copy);\n\n    phi_copy = phi;\n}\n\nstd::cout &lt;&lt; \"Se llego a la tolerancia tras \" &lt;&lt; its &lt;&lt; \" iteraciones.\" &lt;&lt; std::endl;\nreturn 0;\n</code></pre> <p>}</p>","text":""},{"location":"codigo_cpp/Gauss_Seidel_Memloc/","title":"Soluci\u00f3n Paralela de la Ecuaci\u00f3n de Laplace con OpenMP","text":"<p>Este programa resuelve la ecuaci\u00f3n de Laplace en una grilla 2D utilizando el m\u00e9todo de relajaci\u00f3n iterativa, optimizado con OpenMP para computaci\u00f3n paralela.</p>"},{"location":"codigo_cpp/Gauss_Seidel_Memloc/#codigo-fuente","title":"C\u00f3digo Fuente","text":"<p>```cpp</p>"},{"location":"codigo_cpp/Gauss_Seidel_Memloc/#include","title":"include","text":""},{"location":"codigo_cpp/Gauss_Seidel_Memloc/#include_1","title":"include","text":""},{"location":"codigo_cpp/Gauss_Seidel_Memloc/#include-para-stdabs","title":"include  // Para std::abs","text":""},{"location":"codigo_cpp/Gauss_Seidel_Memloc/#include-para-stdmax","title":"include  // Para std::max","text":""},{"location":"codigo_cpp/Gauss_Seidel_Memloc/#include-openmp","title":"include  // OpenMP","text":""},{"location":"codigo_cpp/Gauss_Seidel_Memloc/#include-para-medir-tiempo","title":"include  // Para medir tiempo <p>double seconds() {   struct timeval tmp;   double sec;   gettimeofday(&amp;tmp, (struct timezone *)0);   sec = tmp.tv_sec + ((double)tmp.tv_usec) / 1000000.0;</p> <p>return sec; }</p> <p>double calcular_delta(const std::vector &amp;phi, const std::vector &amp;phi_copy) {     double delta = 0.0;     for (size_t i = 0; i &lt; phi.size(); ++i) {         delta = std::max(delta, std::abs(phi[i] - phi_copy[i]));     }     return delta; } <p>int main(int argc, char* argv[]) {     if (argc != 7) {         std::cerr &lt;&lt; \"Usage: \" &lt;&lt; argv[0] &lt;&lt; \" --N [Tama\u00f1o lineal de la grilla cuadrada (NxN)] --t [Tolerancia] --L [Tama\u00f1o lineal del capacitor cuadrado (LxL)]\" &lt;&lt; std::endl;         return 1;     }</p> <pre><code>std::cout &lt;&lt; \"Bienvenido.\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Se est\u00e1 calculando la soluci\u00f3n de la ecuaci\u00f3n de Laplace bajo los par\u00e1metros definidos...\" &lt;&lt; std::endl;\n\nint N = atoi(argv[2]);\ndouble tolerance = atof(argv[4]);\nint L = atoi(argv[6]);\nint grilla_size = N + 1;\n\nstd::vector&lt;double&gt; phi(grilla_size * grilla_size, 0.0);\n\nint start_y = (N / L) * 2.0;\nint end_y = (N / L) * 8.0;\nint plate_x1 = (N / L) * 2.0;\nint plate_x2 = (N / L) * 8.0;\n\nfor (int i = start_y; i &lt; end_y; ++i) {\n    phi[i * grilla_size + plate_x1] = 1.0;\n    phi[i * grilla_size + plate_x2] = -1.0;\n}\n\nstd::vector&lt;double&gt; phi_copy = phi;\n\ndouble delta = 1.0;\nint its = 0;\nint num_procs;\ndouble time_1 = seconds();\n\nwhile (delta &gt; tolerance) {\n    its++;\n</code></pre>","text":""},{"location":"codigo_cpp/Gauss_Seidel_Memloc/#pragma-omp-parallel","title":"pragma omp parallel <pre><code>    {\n        num_procs = omp_get_num_threads();\n</code></pre>","text":""},{"location":"codigo_cpp/Gauss_Seidel_Memloc/#pragma-omp-for","title":"pragma omp for <pre><code>        for (int i = 1; i &lt; N; ++i) {\n            for (int j = 1; j &lt; N; ++j) {\n                if ((i &gt;= start_y &amp;&amp; i &lt;= end_y) &amp;&amp; (j == plate_x1 || j == plate_x2)) {\n                    // No se modifica la placa\n                } else {\n                    phi[i * grilla_size + j] = (1.0 / 4.0) *\n                        (phi[(i + 1) * grilla_size + j] +\n                         phi[(i - 1) * grilla_size + j] +\n                         phi[i * grilla_size + (j + 1)] +\n                         phi[i * grilla_size + (j - 1)]);\n                }\n            }\n        }\n    }\n\n    delta = calcular_delta(phi, phi_copy);\n    phi_copy = phi;\n}\n\ndouble time_2 = seconds();\nstd::cout &lt;&lt; \"Se lleg\u00f3 a la tolerancia tras \" &lt;&lt; its &lt;&lt; \" iteraciones.\" &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"N\u00famero de hilos: \" &lt;&lt; num_procs &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"Tiempo total: \" &lt;&lt; time_2 - time_1 &lt;&lt; \" segundos\" &lt;&lt; std::endl;\n\nreturn 0;\n</code></pre> <p>}</p>","text":""},{"location":"notebooks/jacobi_modificado/","title":"M\u00e9todo de Relajaci\u00f3n de Jacobi Modificado","text":"<p>Este notebook implementa una mejora al m\u00e9todo de Jacobi, a\u00f1adiendo sobre-relajaci\u00f3n para acelerar la convergencia en sistemas lineales.</p> <p>```python import numpy as np import matplotlib.pyplot as plt</p> <p>def jacobi_relaxation_mod(N, tolerance, L, V1, V2, omega):     # Inicializar la matriz phi (potencial el\u00e9ctrico)     phi = np.zeros((N + 1, N + 1), dtype=float)</p> <pre><code># Aplicar condiciones de frontera\nphi[int((N / L) * 2):int((N / L) * 8), int((N / L) * 2)] = V1\nphi[int((N / L) * 2):int((N / L) * 8), int((N / L) * 8)] = V2\n\ndelta = 1.0\niteration = 0\n\nwhile delta &gt; tolerance:\n    phi_new = phi.copy()\n    iteration += 1\n    phi_new[1:N, 1:N] = (1.0 + omega) * 0.25 * (\n        phi[2:N + 1, 1:N] + phi[0:N - 1, 1:N] + \n        phi[1:N, 2:N + 1] + phi[1:N, 0:N - 1]\n    ) - omega * phi[1:N, 1:N]\n\n    phi_new[int((N / L) * 2):int((N / L) * 8), int((N / L) * 2)] = V1\n    phi_new[int((N / L) * 2):int((N / L) * 8), int((N / L) * 8)] = V2\n\n    delta = np.max(np.abs(phi - phi_new))\n    phi = phi_new\n\nprint(f\"El m\u00e9todo convergi\u00f3 en {iteration} iteraciones.\")\nreturn phi, iteration\n</code></pre> <p>phi, num_iterations = jacobi_relaxation_mod(100, 1e-3, 10, 1, -1, 1.5)</p> <p>El m\u00e9todo convergi\u00f3 en 523 iteraciones.</p>"},{"location":"notebooks/jacobi_modificado/#visualizar-el-resultado","title":"Visualizar el resultado","text":"<p>plt.figure(figsize=(8, 6)) plt.imshow(phi, extent=[0, 10, 0, 10], origin='lower', cmap='viridis', interpolation='bilinear') plt.colorbar(label='Potencial el\u00e9ctrico (phi)') plt.title(f'Distribuci\u00f3n del Potencial El\u00e9ctrico - Iteraciones: {num_iterations}') plt.xlabel('x') plt.ylabel('y') plt.show()</p>"},{"location":"scripts/Gauss_Seidel/","title":"M\u00e9todo de Gauss-Seidel","text":"<p>Este script implementa el m\u00e9todo de Gauss-Seidel para resolver sistemas de ecuaciones en una grilla 2D. Este m\u00e9todo es \u00fatil para simular el comportamiento del potencial el\u00e9ctrico en sistemas discretizados.</p>"},{"location":"scripts/Gauss_Seidel/#codigo-en-python","title":"C\u00f3digo en Python","text":"<p>```python</p>"},{"location":"scripts/Gauss_Seidel/#usrbinenv-python","title":"!/usr/bin/env python","text":"<p>import numpy as np</p> <p>def gauss_seidel(N=100, tolerance=1e-5, L=10, V1=1, V2=-1):     # Iniciaci\u00f3n de phi     phi = np.zeros((N + 1, N + 1), dtype=float)</p> <pre><code># Condiciones iniciales (placas)\nphi[int((N/L)*2):int((N/L)*8), int((N/L)*2)] = V1\nphi[int((N/L)*2):int((N/L)*8), int((N/L)*8)] = V2\n\n# Copia para evaluar el error\nphi_copy = phi.copy()\n\ndelta = 1.0\nits = 0\n\nwhile delta &gt; tolerance:\n    its += 1\n\n    # Iteraci\u00f3n de Gauss-Seidel\n    for i in range(1, N):\n        for j in range(1, N):\n            phi[i, j] = (phi[i+1, j] + phi[i-1, j] + phi[i, j+1] + phi[i, j-1]) / 4.0\n\n    # Restauro el potencial en las placas\n    phi[int((N / L) * 2):int((N / L) * 8), int((N / L) * 2)] = V1\n    phi[int((N / L) * 2):int((N / L) * 8), int((N / L) * 8)] = V2\n\n    # Evaluar la convergencia\n    delta = np.max(np.abs(phi - phi_copy))\n    phi_copy = phi.copy()\n\nreturn phi, its\n</code></pre> <p>gauss_vals, iterations = gauss_seidel() print(iterations)</p>"},{"location":"scripts/Relajacion_Jacobi/","title":"Relajaci\u00f3n Jacobi","text":"<p>Este script implementa el m\u00e9todo de relajaci\u00f3n Jacobi para resolver sistemas de ecuaciones en una grilla 2D. Es \u00fatil en aplicaciones como simulaciones de potencial el\u00e9ctrico.</p>"},{"location":"scripts/Relajacion_Jacobi/#codigo","title":"C\u00f3digo","text":"<p>```python</p>"},{"location":"scripts/Relajacion_Jacobi/#usrbinenv-python","title":"!/usr/bin/env python","text":"<p>import numpy as np ''' Argumentos:      N: el tama\u00f1o lineal de la grilla cuadrada (NxN)      Tolerancia     L: el tama\u00f1o lineal del capacitor cuadrado (LxL)     Primer y segundo voltaje en las placas ''' def jacobi_relaxation(N=100, tolerance=1e-5, L=10, V1=1, V2=-1):     # Iniciaci\u00f3n de phi     phi = np.zeros((N + 1, N + 1), dtype=float)     # Condiciones iniciales (placas)     phi[int((N/L)2):int((N/L)8),int((N/L)2)] = V1     phi[int((N/L)2):int((N/L)8),int((N/L)8)] = V2</p> <pre><code>delta = 1.0\nits = 0\n\nwhile delta &gt; tolerance:\n    its += 1\n    # Actualizaci\u00f3n de phi usando Jacobi\n    phi_new = phi.copy()\n    phi_new[1:N, 1:N] = (1.0/4.0) * (\n        phi[2:N + 1, 1:N] + phi[0:N - 1, 1:N] +\n        phi[1:N, 2:N + 1] + phi[1:N, 0:N - 1]\n    )\n    # Restauro el potencial en las placas\n    phi_new[int((N / L) * 2):int((N / L) * 8), int((N / L) * 2)] = V1\n    phi_new[int((N / L) * 2):int((N / L) * 8), int((N / L) * 8)] = V2\n\n    delta = np.max(np.abs(phi - phi_new))\n    phi = phi_new\n\nreturn phi, its\n</code></pre> <p>jacobi_vals, iterations = jacobi_relaxation() print(iterations)</p> <p>''' En el jupyter: import matplotlib.pyplot as plt import matplotlib.cm as cm</p> <p>plt.imshow(jacobi_vals) plt.gray() plt.show() '''</p>"}]}