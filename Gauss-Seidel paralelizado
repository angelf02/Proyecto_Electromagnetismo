#include <iostream>
#include <vector>
#include <cmath> // Para std::abs
#include <algorithm> // Para std::max
#include <mpi.h>

double calcular_delta(const std::vector<double> &phi, const std::vector<double> &phi_copy) {
	double delta = 0.0;
	for (size_t i = 0; i < phi.size(); ++i) {
		delta = std::max(delta, std::abs(phi[i] - phi_copy[i]));
	}
	return delta;
}

int main(int argc, char* argv[]) {
	if (argc != 7) {
		std::cerr << "Usage: " << argv[0] << " --N [Tamaño lineal de la grilla cuadrada (NxN)] --t [Tolerancia] --L [TamaC1o lineal del capacitor cuadrado (LxL)]" << std::endl;
		return 1;
	}

	std::cout << "Bienvenido." << std::endl;
	std::cout << "Se está calculando la solución de la ecuación de Laplace bajo los parámetros definidos..." 
	
	// Inicialización del ambiente MPI
  int size, rank;
  MPI_Init(&argc, &argv);
 
  MPI_Comm_size(MPI_COMM_WORLD, &size);
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);

  int tag = 0;
  MPI_Init(NULL, NULL);  // Sincroniza los resultados entre los procesos utilizando MPI 

  sendbuff = rank;
  MPI_Status stat;

	int N = atoi(argv[2]);  // Tamaño de la grilla (NxN)
	double tolerance = atof(argv[4]);  // Tolerancia
	int L = atoi(argv[6]);  // Tamaño lineal del capacitor físico
	int grilla_size = N + 1;  // Tamaño total de la grilla (incluye frontera)

	std::vector<double> phi(grilla_size * grilla_size, 0.0);

	// Se convierte las dimensiones físicas del capacitor a índices en la grilla
	int start_y = (N/L) * 2.0;  // Coordenada inicial (y = 2cm)
	int end_y = (N/L) * 8.0;    // Coordenada final (y= 8cm)
	int plate_x1 = (N / L) * 2.0; // Línea vertical izquierda (x = 2cm)
	int plate_x2 = (N / L) * 8.0; // Línea vertical derecha (x = 8cm)

	// Condiciones iniciales en las placas
	for (int i = start_y; i < end_y; ++i) {
		phi[i * grilla_size + plate_x1] = 1.0;  // +1V en la placa izquierda
		phi[i * grilla_size + plate_x2] = -1.0; // -1V en la placa derecha
	}

	std::vector<double> phi_copy = phi; // Copia inicial de phi

	double delta = 1.0;
	int its = 0;

	while (delta > tolerance) {
		its++;

		// Se actualiza los valores de phi en toda la grilla excepto en los bordes
		for (int i = 1; i < N; ++i) {
			for (int j = 1; j < N; ++j) {
				phi[i * grilla_size + j] = (1.0 / 4.0) *
				                           (phi[(i + 1) * grilla_size + j] +
				                            phi[(i - 1) * grilla_size + j] +
				                            phi[i * grilla_size + (j + 1)] +
				                            phi[i * grilla_size + (j - 1)]);
			}
		}

  // Dividiendo el rango del ciclo 

		int its = 100; // Número total de iteraciones
		int local_start = world_rank * (its / world_size);        // Inicio local
		int local_end = (world_rank + 1) * (its / world_size);    // Fin local
		
		// El último proceso debe cubrir las iteraciones que falten 

		if (world_rank == world_size - 1) {
        local_end = its;
    }

    // Restauro el potencial en las placas ya que este sí fue modificado
		for (int i = start_y; i < end_y; ++i) {
			phi[i * grilla_size + plate_x1] = 1.0;
			phi[i * grilla_size + plate_x2] = -1.0;
		}

		delta = calcular_delta(phi, phi_copy);

		phi_copy = phi; // Actualizamos phi_copy con los nuevos valores de phi
	}

	std::cout << "Se llego a la tolerancia tras " << its << " iteraciones." << std::endl;

	return 0;
}
